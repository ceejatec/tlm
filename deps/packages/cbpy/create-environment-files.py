#!/usr/bin/env python3

"""
Copyright 2021-Present Couchbase, Inc.

Use of this software is governed by the Business Source License included in
the file licenses/BSL-Couchbase.txt.  As of the Change Date specified in that
file, in accordance with the Business Source License, use of this software will
be governed by the Apache License, Version 2.0, included in the file
licenses/APL2.txt.
"""

# This script is responsible for reading the files in ./platforms and writing
# the relevant info to the various ../environment-${platform}.txt files
#
# If it encounters issues in ../couchbase-server-black-duck-manifest.yaml it
# will error out with information about what changes are required.

import os
import re
import sys
import yaml
from shutil import copy
from string import Template
from collections import defaultdict

platforms = ["linux-x86_64", "linux-aarch64", "osx-x86_64", "osx-arm64", "win"]
blackduck_manifest = yaml.safe_load(open("couchbase-server-black-duck-manifest.yaml"))
bd_ignored = [x.strip() for x in open("blackduck-ignore.txt").readlines() if not x.startswith("#") and x != ""]

def dd():
    return defaultdict(dd)

def comment(s):
    return f"#{' ' if len(s.strip()) > 0 else ''}{s}"

def raw_version_string(v):
    """
    returns a given string minus the leading v/V, to ease comparison
    """
    if str(v).lower()[0] == "v":
        return str(v[1:])
    return str(v)

def get_version_dict(f):
    """
    Retrieve a dict of product:versions from a requirements.txt
    style text file
    """
    d = {}
    for line in open(f).readlines():
        line = line.strip()
        if not line.startswith("#") and line != "":
            [dep, ver] = line.split("=")
            d[dep] = ver
    return d

def get_deps():
    """ Reads all platform files """
    deps = {}
    for platform in platforms:
        deps[platform] = {}
        lines = [f.strip() for f in open(f"package-lists/{platform}").readlines() if not f.startswith("#") and f != ""]
        for line in lines:
            [package, version] = re.split(r'\s+', line)[0:2]
            deps[platform][package] = version
    return deps

def update_cb_versions(cb_dependencies, cb_stubs, deps):
    """
    cb-dependencies/stubs versions can drift on update
    We need to ensure we're capturing the updated version information
    """
    for platform in platforms:
        for dep in deps[platform]:
            if dep in cb_dependencies and cb_dependencies[dep] != deps[platform][dep]:
                cb_dependencies[dep] = deps[platform][dep]
            if dep in cb_stubs and cb_stubs[dep] != deps[platform][dep]:
                cb_stubs[dep] = deps[platform][dep]

def inject_template(f, template, lines_before=1, lines_after=1):
    """ Formats and injects a template into f """
    template_lines = list(map(comment, open(f"templates/{template}").readlines()))
    outlines = (
        ["\n"] * lines_before +
        template_lines +
        ["\n"] * lines_after)
    f.writelines(outlines)

def write_environment_files(deps):
    """ Write the various environment files """
    # Write environment-base
    for platform in platforms:
        platform_specific_deps = []
        with open(f"environment-{platform}.txt", "w") as f:
            inject_template(f, "autogenerated-warning", lines_before=0, lines_after=0)
            inject_template(f, "explicit", lines_before=0)
            # architecture specific dependencies
            try:
                platform_depfile = open(f"cb-dependencies-{platform}.txt", "r")
                for platform_specific_dep in platform_depfile:
                    if re.search(f"^[a-zA-Z]+", platform_specific_dep):
                        f.write(platform_specific_dep)
                        platform_specific_deps.append(platform_specific_dep.split("=")[0])
            except FileNotFoundError as e:
                pass
            # global dependencies
            for dep in cb_dependencies:
                f.write(f"{dep}={cb_dependencies[dep]}\n")
            inject_template(f, "stubs")
            for dep in cb_stubs:
                f.write(f"{dep}={cb_stubs[dep]}\n")
            inject_template(f, "transitive")
            for dep in deps[platform]:
                if dep not in cb_dependencies and dep not in cb_stubs and dep not in platform_specific_deps:
                    f.write(f"{dep}={deps[platform][dep]}\n")
    print("Environment files saved in ../")

def detect_blackduck_drift():
    blackduck = dd()
    # Figure out what packages have drifted or are missing from black duck manifest
    for target_platform in deps:
        for dep in deps[target_platform]:
            if dep in cb_stubs or dep in bd_ignored:
                continue
            else:
                if dep in blackduck_manifest['components']:
                    bd_dep_name = dep
                else:
                    blackduck['missing'][dep] = deps[target_platform][dep]
                    continue
                bd_vers = list(map(raw_version_string, blackduck_manifest['components'][bd_dep_name]['versions']))
                if deps[target_platform][dep] in bd_vers:
                    continue
                else:
                    blackduck['drifted'][dep] = { "version": deps[target_platform][dep],"bd-versions": bd_vers}

    # Figure out what packages have been removed from black duck manifest
    for bd_dep in blackduck_manifest['components']:
        found = False
        for target_platform in deps:
            for dep in deps[target_platform]:
                if dep == bd_dep:
                    found = True
        if not found:
            blackduck['removed'][bd_dep] = ""

    # If we've got missing/drifted/removed packages, just show the relevant
    # info and error out
    if any(problem in blackduck for problem in ['missing', 'drifted', 'removed']):
        print("ERROR: couchbase-server-black-duck-manifest.yaml is incorrect!")
        print("no environment files will be generated until the below items have been actioned")
        if blackduck['missing']:
            print()
            print("Missing deps:")
            for dep in blackduck['missing']:
                print(f"   {dep} ({blackduck['missing'][dep]})")
        if blackduck['drifted']:
            print()
            print("Drifted deps:")
            for dep in blackduck['drifted']:
                print("  ", dep, blackduck['drifted'][dep])
        if blackduck['removed']:
            print()
            print("Removed deps:")
            for dep in blackduck['removed']:
                print("  ", dep)
        sys.exit(1)

cb_stubs = get_version_dict("cb-stubs.txt")
cb_dependencies = get_version_dict("cb-dependencies.txt")
deps = get_deps()
update_cb_versions(cb_dependencies, cb_stubs, deps)
detect_blackduck_drift()
write_environment_files(deps)
